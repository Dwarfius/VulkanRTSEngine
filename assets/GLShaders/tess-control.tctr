#version 420
#extension GL_ARB_separate_shader_objects : enable

layout(vertices=1) out;

layout (std140, binding = 0) uniform ObjectMatricesAdapter
{
	mat4 Model;
	mat4 ModelView;
	mat4 MVP;
};

layout (std140, binding = 1) uniform TerrainAdapter
{
	vec3 GridOrigin;
	float TileSize;
	int GridWidth;
	int GridHeight;
	float YScale;
};

layout (std140, binding = 2) uniform CameraAdapter
{
	mat4 CamView;
	mat4 CamProj;
	// TODO: add ability to adapters to have arrays
	vec4 FrustumPlaneLeft;
	vec4 FrustumPlaneRight;
	vec4 FrustumPlaneDown;
	vec4 FrustumPlaneUp;
	vec4 FrustumPlaneFar;
	vec4 FrustumPlaneNear;
	vec3 CamPos;
	vec2 Viewport;
};

layout(location = 0) in DataIn
{
	vec2 TexCoords;
	int CheckerInd;
} In[];

layout(location = 0) out DataOut
{
	vec2 TexCoords;
	int TessLevel[4];
	int CheckerInd;
} Out[];

#define SQRT2 1.41421356f
#define TRIANGLE_SIZE 5

// Taken from NVidia's terrain tesselation whitepaper sample
// Sphere-frustum intersection test in world space
bool isVisible(vec3 aPos, float aRadius)
{
    const vec4 pos = vec4(aPos, 1.f);
	bool isOutside = (dot(pos, FrustumPlaneLeft) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneRight) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneDown) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneUp) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneFar) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneNear) + aRadius < 0.0);
	return !isOutside;
}

vec2 localToScreen(vec4 pos)
{
	vec4 p = MVP * pos; // clip space
	p.xy /= p.w; // project (now [-1, 1])
	p.xy = p.xy * 0.5f + 0.5f; // to NDC
	p.xy *= Viewport;
	return p.xy;
}

vec2 eyeToScreen(vec4 pos)
{
	vec4 p = CamProj * pos; // clip space
	p.xy /= p.w; // project (now [-1, 1])
	p.xy = p.xy * 0.5f + 0.5f; // to NDC
	p.xy *= Viewport;
	return p.xy;
}

// given 2 points in Local Space, calculates size(of pixels) of sphere wrapping
// an edge transformed to screen space
float tessViaEdgeSphere(vec3 v1, vec3 v2, float sphereRadius)
{
	vec3 midPointLS = (v1 + v2) * 0.5f;
	vec4 centerES = ModelView * vec4(midPointLS, 1.f);
	vec4 p1ES = centerES - vec4(sphereRadius, 0, 0, 0);
	vec4 p2ES = centerES + vec4(sphereRadius, 0, 0, 0);
	vec2 midPointSS = eyeToScreen(p1ES);
	vec2 perpEyePointSS = eyeToScreen(p2ES);
	float d = distance(midPointSS, perpEyePointSS);
	return clamp(d / TRIANGLE_SIZE, 1, 64);
}

void main() 
{
	vec3 avgHeightPosLS = gl_in[gl_InvocationID].gl_Position.xyz + vec3(0, YScale / 2.f, 0);
	const vec3 centerPosWS = (Model * vec4(avgHeightPosLS, 1.f)).xyz;
	const float halfSize = TileSize / 2.f;
	if(isVisible(centerPosWS, halfSize * SQRT2)) // sphere around entire tile
	{
		vec3 topLeftLS = gl_in[gl_InvocationID].gl_Position.xyz + vec3(-halfSize, 0, halfSize);
		vec3 topRightLS = gl_in[gl_InvocationID].gl_Position.xyz + vec3(halfSize, 0, halfSize);
		vec3 bottomLeftLS = gl_in[gl_InvocationID].gl_Position.xyz + vec3(-halfSize, 0, -halfSize);
		vec3 bottomRightLS = gl_in[gl_InvocationID].gl_Position.xyz + vec3(halfSize, 0, -halfSize);
#if 0
		// use top down distance
		topLeftLS.y = CamPos.y;
		topRightLS.y = CamPos.y;
		bottomLeftLS.y = CamPos.y;
		bottomRightLS.y = CamPos.y;
#endif

		gl_TessLevelOuter[0] = tessViaEdgeSphere(topLeftLS, bottomLeftLS, halfSize); // left
		gl_TessLevelOuter[1] = tessViaEdgeSphere(bottomLeftLS, bottomRightLS, halfSize); // bottom
		gl_TessLevelOuter[2] = tessViaEdgeSphere(bottomRightLS, topRightLS, halfSize); // right
		gl_TessLevelOuter[3] = tessViaEdgeSphere(topRightLS, topLeftLS, halfSize); // top

		// calc interior tessellation level - use average of outer levels
		gl_TessLevelInner[0] = 0.5f * (gl_TessLevelOuter[1] + gl_TessLevelOuter[3]);
    	gl_TessLevelInner[1] = 0.5f * (gl_TessLevelOuter[0] + gl_TessLevelOuter[2]);
	}
	else
	{
		gl_TessLevelOuter[0] = -1;
		gl_TessLevelOuter[1] = -1;
		gl_TessLevelOuter[2] = -1;
		gl_TessLevelOuter[3] = -1;

		gl_TessLevelInner[0] = -1;
		gl_TessLevelInner[1] = -1;
	}

	for(int i=0; i<4; i++)
	{
		Out[gl_InvocationID].TessLevel[i] = int(gl_TessLevelOuter[i]);
	}

	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	Out[gl_InvocationID].TexCoords = In[gl_InvocationID].TexCoords;
	Out[gl_InvocationID].CheckerInd = In[gl_InvocationID].CheckerInd;
}
