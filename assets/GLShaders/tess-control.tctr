#version 420
#extension GL_ARB_separate_shader_objects : enable

layout(vertices=1) out;

layout (std140, binding = 0) uniform ObjectMatricesAdapter
{
	mat4 Model;
	mat4 ModelView;
	mat4 MVP;
};

layout (std140, binding = 1) uniform TerrainAdapter
{
	vec3 GridOrigin;
	int TileSize;
	int GridWidth;
	int GridHeight;
	float YScale;
};

layout (std140, binding = 2) uniform CameraAdapter
{
	mat4 CamView;
	mat4 CamProj;
	// TODO: add ability to adapters to have arrays
	vec4 FrustumPlaneLeft;
	vec4 FrustumPlaneRight;
	vec4 FrustumPlaneDown;
	vec4 FrustumPlaneUp;
	vec4 FrustumPlaneFar;
	vec4 FrustumPlaneNear;
	vec3 CamPos;
	vec2 Viewport;
};

layout(location = 0) in DataIn
{
	mediump vec2 TexCoords;
} In[];

layout(location = 0) out DataOut
{
	mediump vec2 TexCoords;
	int TessLevel;
} Out[];

// Taken from NVidia's terrain tesselation whitepaper sample
// Sphere-frustum intersection test in world space
bool isVisible(vec3 aPos, float aRadius)
{
    const vec4 pos = vec4(aPos, 1.f);
	bool isOutside = (dot(pos, FrustumPlaneLeft) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneRight) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneDown) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneUp) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneFar) + aRadius < 0.0)
		|| (dot(pos, FrustumPlaneNear) + aRadius < 0.0);
	return !isOutside;
}

vec2 clipToScreen(vec4 pos)
{
	vec4 p = pos; // clip space
	p.xy /= p.w; // project (now [-1, 1])
	p.xy *= Viewport;
	return p.xy;
}

// given 2 points, calculates the distance between the 2 points
// in screen space
int edgeTesselation(vec2 v1, vec2 v2)
{
	const float kTriangleSize = 5.f;
	const float dist = distance(v1, v2);
	return int(clamp(dist / kTriangleSize, 1.f, 64.f));
}

// given 2 points in Local Space, calculates edge tesselation by wrapping
// it in a sphere and determining the size in screen space
int edgeTesselationSphere(vec3 v1, vec3 v2, float sphereRadius)
{
	vec3 midPointLS = (v1 + v2) / 2.f;
	vec4 midPointES = ModelView * vec4(midPointLS, 1.f);
	vec4 perpEyePointES = midPointES + vec4(sphereRadius, 0, 0, 0);
	vec4 midPointSS = CamProj * midPointES;
	vec4 perpEyePointSS = CamProj * perpEyePointES;
	return edgeTesselation(clipToScreen(midPointSS), clipToScreen(perpEyePointSS));
}

#define SQRT2 1.41421356f

void main() 
{
	vec4 avgHeightPosLS = gl_in[gl_InvocationID].gl_Position + vec4(0, YScale / 2.f, 0, 0);
	vec3 centerPosWS = (Model * avgHeightPosLS).xyz;
	if(isVisible(centerPosWS, TileSize / 2.f * SQRT2)) // sphere around entire tile
	{
		vec4 topLeftLS = avgHeightPosLS + vec4(-TileSize / 2.f, 0, TileSize / 2.f, 0);
		vec4 topRightLS = avgHeightPosLS + vec4(TileSize / 2.f, 0, TileSize / 2.f, 0);
		vec4 bottomLeftLS = avgHeightPosLS + vec4(-TileSize / 2.f, 0, -TileSize / 2.f, 0);
		vec4 bottomRightLS = avgHeightPosLS + vec4(TileSize / 2.f, 0, -TileSize / 2.f, 0);
#if 0
		vec2 topLeftSS = clipToScreen(MVP * topLeftLS);
		vec2 topRightSS = clipToScreen(MVP * topRightLS);
		vec2 bottomLeftSS = clipToScreen(MVP * bottomLeftLS);
		vec2 bottomRightSS = clipToScreen(MVP * bottomRightLS);

		// TODO: this version isn't accurate when the view direction is parallel with the edge
		// so need to replace it with the bounding sphere logic in view space
		// left
		gl_TessLevelOuter[0] = edgeTesselation(topLeftSS, bottomLeftSS);
		// bottom
		gl_TessLevelOuter[1] = edgeTesselation(bottomLeftSS, bottomRightSS);
		// right
		gl_TessLevelOuter[2] = edgeTesselation(bottomRightSS, topRightSS);
		// top
		gl_TessLevelOuter[3] = edgeTesselation(topLeftSS, topRightSS);
#else
		// left
		gl_TessLevelOuter[0] = edgeTesselationSphere(topLeftLS.xyz, bottomLeftLS.xyz, TileSize / 2.f);
		// bottom
		gl_TessLevelOuter[1] = edgeTesselationSphere(bottomLeftLS.xyz, bottomRightLS.xyz, TileSize / 2.f);
		// right
		gl_TessLevelOuter[2] = edgeTesselationSphere(bottomRightLS.xyz, topRightLS.xyz, TileSize / 2.f);
		// top
		gl_TessLevelOuter[3] = edgeTesselationSphere(topLeftLS.xyz, topRightLS.xyz, TileSize / 2.f);
#endif

		Out[gl_InvocationID].TessLevel = int(max(max(gl_TessLevelOuter[0], gl_TessLevelOuter[1]), max(gl_TessLevelOuter[2], gl_TessLevelOuter[3])));
	}
	else
	{
		gl_TessLevelOuter[0] = -1;
		gl_TessLevelOuter[1] = -1;
		gl_TessLevelOuter[2] = -1;
		gl_TessLevelOuter[3] = -1;
	}

	// calc interior tessellation level - use average of outer levels
    gl_TessLevelInner[0] = 0.5 * (gl_TessLevelOuter[1] + gl_TessLevelOuter[3]);
    gl_TessLevelInner[1] = 0.5 * (gl_TessLevelOuter[0] + gl_TessLevelOuter[2]);

	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	Out[gl_InvocationID].TexCoords = In[gl_InvocationID].TexCoords;
}
